[supervisord]
nodaemon=true

; octane
[program:octane]
command=php artisan octane:start --host=0.0.0.0 --port=8000
autostart=true
autorestart=true
redirect_stderr=true
stdout_logfile=/dev/stdout
stderr_logfile=/dev/stderr
stdout_maxbytes=0
stderr_maxbytes=0
stdout_logfile_maxbytes = 0
stderr_logfile_maxbytes = 0

; queue
[program:queue-worker-1]
command=php /var/www/artisan queue:work --tries=3 --timeout=0 --sleep=3
autostart=true
autorestart=true
process_name=%(program_name)s_%(process_num)02d
redirect_stderr=true
stdout_logfile=/dev/stdout
stderr_logfile=/dev/stderr
stdout_maxbytes=0
stderr_maxbytes=0
stdout_logfile_maxbytes = 0
stderr_logfile_maxbytes = 0

; queue
; [program:queue-worker-2]
; command=php artisan queue:work
; autostart=true
; autorestart=true
; process_name=%(program_name)s_%(process_num)02d
; redirect_stderr=true
; stdout_logfile=/dev/stdout
; stderr_logfile=/dev/stderr
; stdout_maxbytes=0
; stderr_maxbytes=0
; stdout_logfile_maxbytes = 0
; stderr_logfile_maxbytes = 0

; scheduler
; this will not solve the main problem: shutdown of automated gcp instances in cloud run (shutdown is based on incoming http request(s))
; I think it will prevent the closure of the GCP courts: we need google scheduler + endpoints for each schedule
; [program:scheduler]
; command=php /var/www/artisan schedule:run
; autostart=true
; autorestart=true
; numprocs=1
; stdout_logfile=/dev/stdout
; stderr_logfile=/dev/stderr
; stdout_maxbytes=0
; stderr_maxbytes=0
; stdout_logfile_maxbytes = 0
; stderr_logfile_maxbytes = 0
; cron=* * * * *
